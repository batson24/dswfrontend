{"ast":null,"code":"var _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _objectSpread = require(\"@babel/runtime/helpers/objectSpread\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar jwt = require('jsonwebtoken');\n\nvar JWS_REGEX = /^[a-zA-Z0-9\\-_]+?\\.[a-zA-Z0-9\\-_]+?\\.([a-zA-Z0-9\\-_]+)?$/;\n\nvar Base64 = require('Base64');\n\nfunction decodeBase64Url(base64UrlString) {\n  try {\n    return Base64.atob(toBase64(base64UrlString));\n  } catch (e) {\n    /* istanbul ignore else */\n    if (e.name === 'InvalidCharacterError') {\n      return undefined;\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction safeJsonParse(thing) {\n  if (_typeof(thing) === 'object') return thing;\n\n  try {\n    return JSON.parse(thing);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction padString(string) {\n  var segmentLength = 4;\n  var diff = string.length % segmentLength;\n  if (!diff) return string;\n  var padLength = segmentLength - diff;\n\n  while (padLength--) {\n    string += '=';\n  }\n\n  return string;\n}\n\nfunction toBase64(base64UrlString) {\n  var b64str = padString(base64UrlString).replace(/\\-/g, '+') // eslint-disable-line no-useless-escape\n  .replace(/_/g, '/');\n  return b64str;\n}\n\nfunction headerFromJWS(jwsSig) {\n  var encodedHeader = jwsSig.split('.', 1)[0];\n  return safeJsonParse(decodeBase64Url(encodedHeader));\n}\n\nexports.headerFromJWS = headerFromJWS;\n\nexports.JWTScopeToken = function (apiSecret, resource, action, opts) {\n  /**\n   * Creates the JWT token for feedId, resource and action using the apiSecret\n   * @method JWTScopeToken\n   * @memberof signing\n   * @private\n   * @param {string} apiSecret - API Secret key\n   * @param {string} resource - JWT payload resource\n   * @param {string} action - JWT payload action\n   * @param {object} [options] - Optional additional options\n   * @param {string} [options.feedId] - JWT payload feed identifier\n   * @param {string} [options.userId] - JWT payload user identifier\n   * @return {string} JWT Token\n   */\n  var options = opts || {},\n      noTimestamp = options.expireTokens ? !options.expireTokens : true;\n  var payload = {\n    resource: resource,\n    action: action\n  };\n\n  if (options.feedId) {\n    payload['feed_id'] = options.feedId;\n  }\n\n  if (options.userId) {\n    payload['user_id'] = options.userId;\n  }\n\n  var token = jwt.sign(payload, apiSecret, {\n    algorithm: 'HS256',\n    noTimestamp: noTimestamp\n  });\n  return token;\n};\n\nexports.JWTUserSessionToken = function (apiSecret, userId) {\n  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var jwtOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  /**\n   * Creates the JWT token that can be used for a UserSession\n   * @method JWTUserSessionToken\n   * @memberof signing\n   * @private\n   * @param {string} apiSecret - API Secret key\n   * @param {string} userId - The user_id key in the JWT payload\n   * @param {string} [extraData] - Extra that should be part of the JWT token\n   * @param {object} [jwtOptions] - Options that can be past to jwt.sign\n   * @return {string} JWT Token\n   */\n\n  if (typeof userId !== 'string') {\n    throw new TypeError('userId should be a string');\n  }\n\n  var payload = _objectSpread({\n    user_id: userId\n  }, extraData);\n\n  var opts = _extends({\n    algorithm: 'HS256',\n    noTimestamp: true\n  }, jwtOptions);\n\n  var token = jwt.sign(payload, apiSecret, opts);\n  return token;\n};\n\nexports.isJWTSignature = exports.isJWT = function (signature) {\n  /**\n   * check if token is a valid JWT token\n   * @method isJWTSignature\n   * @memberof signing\n   * @private\n   * @param {string} signature - Signature to check\n   * @return {boolean}\n   */\n  if (signature == null || signature.length == 0) {\n    return false;\n  }\n\n  var token = signature.split(' ')[1] || signature;\n  return JWS_REGEX.test(token) && !!headerFromJWS(token);\n};","map":{"version":3,"sources":["/Users/batson24/Desktop/Date_Site/frontend/node_modules/getstream/lib/lib/signing.js"],"names":["_extends","require","_objectSpread","_typeof","jwt","JWS_REGEX","Base64","decodeBase64Url","base64UrlString","atob","toBase64","e","name","undefined","safeJsonParse","thing","JSON","parse","padString","string","segmentLength","diff","length","padLength","b64str","replace","headerFromJWS","jwsSig","encodedHeader","split","exports","JWTScopeToken","apiSecret","resource","action","opts","options","noTimestamp","expireTokens","payload","feedId","userId","token","sign","algorithm","JWTUserSessionToken","extraData","arguments","jwtOptions","TypeError","user_id","isJWTSignature","isJWT","signature","test"],"mappings":"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","sourcesContent":["var _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _objectSpread = require(\"@babel/runtime/helpers/objectSpread\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar jwt = require('jsonwebtoken');\n\nvar JWS_REGEX = /^[a-zA-Z0-9\\-_]+?\\.[a-zA-Z0-9\\-_]+?\\.([a-zA-Z0-9\\-_]+)?$/;\n\nvar Base64 = require('Base64');\n\nfunction decodeBase64Url(base64UrlString) {\n  try {\n    return Base64.atob(toBase64(base64UrlString));\n  } catch (e) {\n    /* istanbul ignore else */\n    if (e.name === 'InvalidCharacterError') {\n      return undefined;\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction safeJsonParse(thing) {\n  if (_typeof(thing) === 'object') return thing;\n\n  try {\n    return JSON.parse(thing);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction padString(string) {\n  var segmentLength = 4;\n  var diff = string.length % segmentLength;\n  if (!diff) return string;\n  var padLength = segmentLength - diff;\n\n  while (padLength--) {\n    string += '=';\n  }\n\n  return string;\n}\n\nfunction toBase64(base64UrlString) {\n  var b64str = padString(base64UrlString).replace(/\\-/g, '+') // eslint-disable-line no-useless-escape\n  .replace(/_/g, '/');\n  return b64str;\n}\n\nfunction headerFromJWS(jwsSig) {\n  var encodedHeader = jwsSig.split('.', 1)[0];\n  return safeJsonParse(decodeBase64Url(encodedHeader));\n}\n\nexports.headerFromJWS = headerFromJWS;\n\nexports.JWTScopeToken = function (apiSecret, resource, action, opts) {\n  /**\n   * Creates the JWT token for feedId, resource and action using the apiSecret\n   * @method JWTScopeToken\n   * @memberof signing\n   * @private\n   * @param {string} apiSecret - API Secret key\n   * @param {string} resource - JWT payload resource\n   * @param {string} action - JWT payload action\n   * @param {object} [options] - Optional additional options\n   * @param {string} [options.feedId] - JWT payload feed identifier\n   * @param {string} [options.userId] - JWT payload user identifier\n   * @return {string} JWT Token\n   */\n  var options = opts || {},\n      noTimestamp = options.expireTokens ? !options.expireTokens : true;\n  var payload = {\n    resource: resource,\n    action: action\n  };\n\n  if (options.feedId) {\n    payload['feed_id'] = options.feedId;\n  }\n\n  if (options.userId) {\n    payload['user_id'] = options.userId;\n  }\n\n  var token = jwt.sign(payload, apiSecret, {\n    algorithm: 'HS256',\n    noTimestamp: noTimestamp\n  });\n  return token;\n};\n\nexports.JWTUserSessionToken = function (apiSecret, userId) {\n  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var jwtOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  /**\n   * Creates the JWT token that can be used for a UserSession\n   * @method JWTUserSessionToken\n   * @memberof signing\n   * @private\n   * @param {string} apiSecret - API Secret key\n   * @param {string} userId - The user_id key in the JWT payload\n   * @param {string} [extraData] - Extra that should be part of the JWT token\n   * @param {object} [jwtOptions] - Options that can be past to jwt.sign\n   * @return {string} JWT Token\n   */\n  if (typeof userId !== 'string') {\n    throw new TypeError('userId should be a string');\n  }\n\n  var payload = _objectSpread({\n    user_id: userId\n  }, extraData);\n\n  var opts = _extends({\n    algorithm: 'HS256',\n    noTimestamp: true\n  }, jwtOptions);\n\n  var token = jwt.sign(payload, apiSecret, opts);\n  return token;\n};\n\nexports.isJWTSignature = exports.isJWT = function (signature) {\n  /**\n   * check if token is a valid JWT token\n   * @method isJWTSignature\n   * @memberof signing\n   * @private\n   * @param {string} signature - Signature to check\n   * @return {boolean}\n   */\n  if (signature == null || signature.length == 0) {\n    return false;\n  }\n\n  var token = signature.split(' ')[1] || signature;\n  return JWS_REGEX.test(token) && !!headerFromJWS(token);\n};"]},"metadata":{},"sourceType":"script"}